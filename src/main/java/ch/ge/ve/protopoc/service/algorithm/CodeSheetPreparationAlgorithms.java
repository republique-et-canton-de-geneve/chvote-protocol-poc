package ch.ge.ve.protopoc.service.algorithm;

import ch.ge.ve.protopoc.service.model.*;
import ch.ge.ve.protopoc.service.support.ByteArrayUtils;
import ch.ge.ve.protopoc.service.support.Conversion;
import com.google.common.base.Preconditions;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static ch.ge.ve.protopoc.service.support.ByteArrayUtils.markByteArray;

/**
 * Algorithms related to the preparation of code sheets
 */
public class CodeSheetPreparationAlgorithms {
    private final Conversion conversion = new Conversion();
    private final PublicParameters publicParameters;
    private final int s;

    public CodeSheetPreparationAlgorithms(PublicParameters publicParameters) {
        this.publicParameters = publicParameters;
        s = publicParameters.getS();
    }

    /**
     * Algorithm 7.13: GetSheets
     * <p>Computes the list of code sheets for every voter</p>
     *
     * @param electionSet  the electionSet definition, including bold_v, bold_c, bold_n, bold_k and bold_upper_e
     * @param bold_upper_d the secret voter data generated by each authority for each voter
     *                     (codeSheetData.get(j) = bold_d_j : the list of the voters' secret data for authority j)
     * @return all the relevant information combined for printing on the code sheets
     */
    public List<CodeSheet> getSheets(ElectionSet electionSet, List<List<SecretVoterData>> bold_upper_d) {
        Preconditions.checkArgument(bold_upper_d.size() == publicParameters.getS(),
                String.format("|D| [%d] != s [%d]", bold_upper_d.size(), publicParameters.getS()));
        Preconditions.checkArgument(bold_upper_d.stream().allMatch(
                secretVoterDatas -> secretVoterDatas.size() == electionSet.getVoters().size()),
                "Each authority should have submitted one code sheet per voter");

        List<CodeSheet> codeSheets = new ArrayList<>();
        for (int i = 0; i < electionSet.getVoters().size(); i++) {
            Voter v_i = electionSet.getVoters().get(i);

            // for each authority, get the secret data pertaining to voter i
            final int local_i = i;
            List<SecretVoterData> secretVoterDataList = bold_upper_d.stream()
                    .map(list -> list.get(local_i)).collect(Collectors.toList());

            String upper_x = compute_upper_x(secretVoterDataList);
            String upper_y = compute_upper_y(secretVoterDataList);
            String upper_fc = compute_upper_fc(secretVoterDataList);
            List<String> bold_rc = compute_bold_rc(electionSet, secretVoterDataList);
            List<Integer> bold_k_i = compute_bold_k_i(electionSet, v_i);

            codeSheets.add(getSheet(i, electionSet, bold_k_i, upper_x, upper_y, upper_fc, bold_rc));
        }
        return codeSheets;
    }

    /**
     * X_i = ToByteArray( \sum{j=1,s}(x_{ij}), L_x)
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the byte array conversion of the sum of individual <tt>x_ij</tt>s
     */
    private String compute_upper_x(List<SecretVoterData> secretVoterDataList) {
        BigInteger sum_x_ij = IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getX)
                .reduce(BigInteger::add).orElse(BigInteger.ZERO);
        return conversion.toString(sum_x_ij, publicParameters.getK_x(), publicParameters.getA_x());
    }

    /**
     * Y_i = ToByteArray( \sum{j=1,s}(y_{ij}), L_y)
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the byte array conversion of the sum of individual <tt>y_ij</tt>s
     */
    private String compute_upper_y(List<SecretVoterData> secretVoterDataList) {
        BigInteger sum_y_ij = IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getY)
                .reduce(BigInteger::add).orElse(BigInteger.ZERO);
        //noinspection SuspiciousNameCombination
        return conversion.toString(sum_y_ij, publicParameters.getK_y(), publicParameters.getA_y());
    }

    /**
     * F_i = \xor{j=1,s}(F_{ij})
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the result of xoring the individual <tt>F_ij</tt>s
     */
    private String compute_upper_fc(List<SecretVoterData> secretVoterDataList) {
        List<Character> A_f = publicParameters.getA_f();
        return IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getF)
                .reduce(ByteArrayUtils::xor)
                .map(b -> conversion.toString(b, A_f))
                .orElse("");
    }

    /**
     * 1. RC_ik = \xor{j=1,s}(RC_{ijk})
     * 2. mark byte array
     * 3. convert to string
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return for each k, the result of xoring the individual <tt>RC_ijk</tt>s
     */
    private List<String> compute_bold_rc(ElectionSet electionSet, List<SecretVoterData> secretVoterDataList) {
        List<Character> upper_a_r = publicParameters.getA_r();
        return IntStream.range(0, electionSet.getCandidates().size()).mapToObj(k ->
                IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                        .map(secretVoterData -> secretVoterData.getRc()[k])
                        .reduce(ByteArrayUtils::xor) // 1.
                        .map(upper_r_ik -> markByteArray(upper_r_ik, k, publicParameters.getN_max())) // 2.
                        .map(b -> conversion.toString(b, upper_a_r)) // 3.
                        .orElse("")
        ).collect(Collectors.toList());
    }

    /**
     * k_i = (e_{i,1} * k_1, ..., e_{i,t} * kt)
     *
     * @param electionSet the electionSet definition, including v, c, n, k and E
     * @param v_i         the individual voter
     * @return the vector of allowed number of selections per election for the voter
     */
    private List<Integer> compute_bold_k_i(ElectionSet electionSet, Voter v_i) {
        return electionSet.getElections().stream()
                .map(e -> electionSet.isEligible(v_i, e) ? e.getNumberOfSelections() : 0)
                .collect(Collectors.toList());
    }

    /**
     * Algorithm 7.14: GetSheet
     *
     * @param i           the voter index
     * @param electionSet the electionSet definition, including upper_v, bold_c and bold_n
     * @param bold_k      the number of selections the voter can make for each election
     * @param upper_x     the element to be used for identification
     * @param upper_y     the element to be used for confirmation
     * @param upper_fc    the element to be used as finalization code
     * @param bold_rc     the vector of the elements to be used for return codes
     * @return the elements needed for the voter's code sheet
     */
    private CodeSheet getSheet(Integer i, ElectionSet electionSet, List<Integer> bold_k, String upper_x, String upper_y, String upper_fc,
                               List<String> bold_rc) {
        Voter v_i = electionSet.getVoters().get(i);
        return new CodeSheet(i, v_i, electionSet, bold_k, upper_x, upper_y, upper_fc, bold_rc);
    }
}
