/*-------------------------------------------------------------------------------------------------
 - #%L                                                                                            -
 - chvote-protocol-poc                                                                            -
 - %%                                                                                             -
 - Copyright (C) 2016 - 2017 République et Canton de Genève                                       -
 - %%                                                                                             -
 - This program is free software: you can redistribute it and/or modify                           -
 - it under the terms of the GNU Affero General Public License as published by                    -
 - the Free Software Foundation, either version 3 of the License, or                              -
 - (at your option) any later version.                                                            -
 -                                                                                                -
 - This program is distributed in the hope that it will be useful,                                -
 - but WITHOUT ANY WARRANTY; without even the implied warranty of                                 -
 - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                                   -
 - GNU General Public License for more details.                                                   -
 -                                                                                                -
 - You should have received a copy of the GNU Affero General Public License                       -
 - along with this program. If not, see <http://www.gnu.org/licenses/>.                           -
 - #L%                                                                                            -
 -------------------------------------------------------------------------------------------------*/

package ch.ge.ve.protopoc.service.algorithm;

import ch.ge.ve.protopoc.service.model.*;
import ch.ge.ve.protopoc.service.support.ByteArrayUtils;
import ch.ge.ve.protopoc.service.support.Conversion;
import com.google.common.base.Preconditions;

import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static ch.ge.ve.protopoc.service.support.ByteArrayUtils.markByteArray;

/**
 * Algorithms related to the preparation of code sheets
 */
public class VotingCardPreparationAlgorithms {
    private final Conversion conversion = new Conversion();
    private final PublicParameters publicParameters;
    private final int s;

    public VotingCardPreparationAlgorithms(PublicParameters publicParameters) {
        this.publicParameters = publicParameters;
        s = publicParameters.getS();
    }

    /**
     * Algorithm 7.13: GetVotingCards
     * <p>Computes the voting card (containing all codes) for every voter</p>
     *
     * @param electionSet  the electionSet definition, including bold_v, bold_c, bold_n, bold_k and bold_upper_e
     * @param bold_upper_d the secret voter data generated by each authority for each voter
     *                     (codeSheetData.get(j) = bold_d_j : the list of the voters' secret data for authority j)
     * @return all the relevant information combined for printing on the code sheets
     */
    public List<VotingCard> getVotingCard(ElectionSet electionSet, List<List<SecretVoterData>> bold_upper_d) {
        Preconditions.checkArgument(bold_upper_d.size() == publicParameters.getS(),
                String.format("|D| [%d] != s [%d]", bold_upper_d.size(), publicParameters.getS()));
        Preconditions.checkArgument(bold_upper_d.stream().allMatch(
                secretVoterDatas -> secretVoterDatas.size() == electionSet.getVoters().size()),
                "Each authority should have submitted one code sheet per voter");

        List<VotingCard> votingCards = new ArrayList<>();
        for (int i = 0; i < electionSet.getVoters().size(); i++) {
            Voter v_i = electionSet.getVoters().get(i);

            // for each authority, get the secret data pertaining to voter i
            final int local_i = i;
            List<SecretVoterData> secretVoterDataList = bold_upper_d.stream()
                    .map(list -> list.get(local_i)).collect(Collectors.toList());

            String upper_x = compute_upper_x(secretVoterDataList);
            String upper_y = compute_upper_y(secretVoterDataList);
            String upper_fc = compute_upper_fc(secretVoterDataList);
            List<String> bold_rc = compute_bold_rc(electionSet, secretVoterDataList);
            List<Integer> bold_k_i = compute_bold_k_i(electionSet, v_i);

            votingCards.add(getVotingCard(i, electionSet, bold_k_i, upper_x, upper_y, upper_fc, bold_rc));
        }
        votingCards.sort(Comparator.comparing(VotingCard::getI));
        return votingCards;
    }

    /**
     * upper_x = ToByteArray( \sum{j=1,s}(x_{ij}), L_x)
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the byte array conversion of the sum of individual <tt>x_ij</tt>s
     */
    private String compute_upper_x(List<SecretVoterData> secretVoterDataList) {
        BigInteger sum_x_ij = IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getX)
                .reduce(BigInteger::add).orElse(BigInteger.ZERO);
        Preconditions.checkArgument(sum_x_ij.compareTo(publicParameters.getQ_hat_x()) < 0,
                "the sum of the x_ij's must be lesser than q_hat_x");
        return conversion.toString(sum_x_ij, publicParameters.getL_x(), publicParameters.getUpper_a_x());
    }

    /**
     * upper_y = ToByteArray( \sum{j=1,s}(y_{ij}), L_y)
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the byte array conversion of the sum of individual <tt>y_ij</tt>s
     */
    private String compute_upper_y(List<SecretVoterData> secretVoterDataList) {
        BigInteger sum_y_ij = IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getY)
                .reduce(BigInteger::add).orElse(BigInteger.ZERO);
        Preconditions.checkArgument(sum_y_ij.compareTo(publicParameters.getQ_hat_y()) < 0,
                "the sum of the y_ij's must be lesser than q_hat_y");
        //noinspection SuspiciousNameCombination
        return conversion.toString(sum_y_ij, publicParameters.getL_y(), publicParameters.getUpper_a_y());
    }

    /**
     * upper_fc = \xor{j=1,s}(F_{ij})
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return the result of xoring the individual <tt>F_ij</tt>s
     */
    private String compute_upper_fc(List<SecretVoterData> secretVoterDataList) {
        List<Character> A_f = publicParameters.getUpper_a_f();
        return IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                .map(SecretVoterData::getF)
                .reduce(ByteArrayUtils::xor)
                .map(b -> conversion.toString(b, A_f))
                .orElse("");
    }

    /**
     * 1. RC_ik = \xor{j=1,s}(RC_{ijk})
     * 2. mark byte array
     * 3. convert to string
     *
     * @param secretVoterDataList the secret voter data generated by each of the authorities for this voter
     * @return for each k, the result of xoring the individual <tt>RC_ijk</tt>s
     */
    private List<String> compute_bold_rc(ElectionSet electionSet, List<SecretVoterData> secretVoterDataList) {
        List<Character> upper_a_r = publicParameters.getUpper_a_r();
        return IntStream.range(0, electionSet.getCandidates().size()).mapToObj(k ->
                IntStream.range(0, s).mapToObj(secretVoterDataList::get)
                        .map(secretVoterData -> secretVoterData.getRc()[k])
                        .reduce(ByteArrayUtils::xor) // 1.
                        .map(upper_r_ik -> markByteArray(upper_r_ik, k, publicParameters.getN_max())) // 2.
                        .map(b -> conversion.toString(b, upper_a_r)) // 3.
                        .orElse("")
        ).collect(Collectors.toList());
    }

    /**
     * k_i = (e_{i,1} * k_1, ..., e_{i,t} * kt)
     *
     * @param electionSet the electionSet definition, including v, c, n, k and E
     * @param v_i         the individual voter
     * @return the vector of allowed number of selections per election for the voter
     */
    private List<Integer> compute_bold_k_i(ElectionSet electionSet, Voter v_i) {
        return electionSet.getElections().stream()
                .map(e -> electionSet.isEligible(v_i, e) ? e.getNumberOfSelections() : 0)
                .collect(Collectors.toList());
    }

    /**
     * Algorithm 7.14: GetVotingCard
     *
     * @param i           the voter index
     * @param electionSet the electionSet definition, including upper_v, bold_c and bold_n
     * @param bold_k      the number of selections the voter can make for each election
     * @param upper_x     the element to be used for identification
     * @param upper_y     the element to be used for confirmation
     * @param upper_fc    the element to be used as finalization code
     * @param bold_rc     the vector of the elements to be used for the verification codes
     * @return the elements needed for the voter's code sheet
     */
    private VotingCard getVotingCard(Integer i, ElectionSet electionSet, List<Integer> bold_k, String upper_x, String upper_y, String upper_fc,
                                     List<String> bold_rc) {
        Voter v_i = electionSet.getVoters().get(i);
        return new VotingCard(i, v_i, electionSet, bold_k, upper_x, upper_y, upper_fc, bold_rc);
    }
}
